<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Palavras</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
}

.container {
    width: 100%;
    max-width: 800px;
    padding: 20px;
}

.screen {
    background: rgba(255, 255, 255, 0.1);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    backdrop-filter: blur(4px);
    border: 1px solid rgba(255, 255, 255, 0.18);
}

.hidden {
    display: none !important;
}

/* Tela inicial */
#initial-screen {
    text-align: center;
}

#initial-screen h1 {
    font-size: 2.5em;
    margin-bottom: 30px;
    color: #4CAF50;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.input-group {
    margin: 20px 0;
}

input[type="text"] {
    padding: 12px 20px;
    font-size: 16px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    width: 250px;
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    transition: all 0.3s ease;
}

input[type="text"]:focus {
    outline: none;
    border-color: #4CAF50;
    background: rgba(255, 255, 255, 0.15);
}

input[type="text"]::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

.button-group {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-bottom: 30px;
}

button {
    padding: 12px 25px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    font-weight: 600;
    letter-spacing: 1px;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

button:hover {
    background-color: #45a049;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

button:active {
    transform: translateY(0);
}

/* Sala de espera */
#waiting-screen {
    text-align: center;
}

#waiting-screen h2 {
    color: #4CAF50;
    margin-bottom: 20px;
}

.room-info {
    background: rgba(255, 255, 255, 0.05);
    padding: 15px;
    border-radius: 8px;
    margin: 20px 0;
    text-align: left;
}

.room-code {
    font-size: 24px;
    font-weight: bold;
    color: #4CAF50;
    text-align: center;
    padding: 10px;
    background: rgba(76, 175, 80, 0.1);
    border-radius: 8px;
    margin: 10px 0;
}

.players-list {
    margin: 20px 0;
    padding: 0;
    list-style: none;
}

.players-list li {
    padding: 10px;
    margin: 5px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    display: flex;
    align-items: center;
}

.players-list li::before {
    content: "•";
    color: #4CAF50;
    margin-right: 10px;
    font-size: 20px;
}

.start-game-btn {
    margin-top: 20px;
    background: #4CAF50;
    width: 200px;
}

/* Tela do jogo */
.game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

#game-grid {
    display: grid;
    grid-template-rows: repeat(6, 1fr);
    gap: 8px;
    margin: 30px auto;
    max-width: 350px;
}

.grid-row {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 8px;
}

.grid-cell {
    aspect-ratio: 1;
    border: 2px solid rgba(255, 255, 255, 0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 28px;
    font-weight: bold;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
    background: rgba(255, 255, 255, 0.05);
    color: #fff;
}

.grid-cell.filled {
    border-color: rgba(255, 255, 255, 0.4);
    transform: scale(1.02);
}

.grid-cell.current {
    border-color: #4CAF50;
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
    transform: scale(1.05);
}

.grid-cell:hover:not(.filled):not(.green):not(.yellow):not(.gray) {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.1);
}

.grid-cell.green {
    background-color: #4CAF50;
    color: white;
    border-color: #4CAF50;
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
}

.grid-cell.yellow {
    background-color: #ffd700;
    color: white;
    border-color: #ffd700;
    transform: scale(1.02);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

.grid-cell.gray {
    background-color: #666;
    color: white;
    border-color: #666;
    opacity: 0.7;
}

#keyboard {
    display: grid;
    gap: 8px;
    margin-top: 30px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
}

.keyboard-row {
    display: flex;
    justify-content: center;
    gap: 6px;
}

.key {
    padding: 20px;
    min-width: 40px;
    text-align: center;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    color: #fff;
    transition: all 0.3s ease;
    text-transform: uppercase;
}

.key:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
}

.key.correct {
    background-color: #4CAF50;
    color: white;
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
}

.key.present {
    background-color: #ffd700;
    color: white;
    transform: scale(1.02);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

.key.disabled {
    background-color: #666;
    color: rgba(255, 255, 255, 0.5);
    cursor: not-allowed;
    opacity: 0.7;
    transform: scale(0.95);
}

/* Tela de fim de jogo */
#end-screen {
    text-align: center;
}

#end-message {
    color: #4CAF50;
    font-size: 24px;
    margin-bottom: 20px;
}

#game-stats {
    margin: 20px 0;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

#leaderboard {
    margin: 20px 0;
}

#leaderboard h3 {
    color: #4CAF50;
    margin-bottom: 15px;
}

#leaderboard-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    overflow: hidden;
}

#leaderboard-table th,
#leaderboard-table td {
    padding: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #fff;
}

#leaderboard-table th {
    background: rgba(76, 175, 80, 0.2);
    font-weight: bold;
}

#leaderboard-table tr:nth-child(even) {
    background: rgba(255, 255, 255, 0.02);
}

#play-again {
    margin-top: 30px;
    padding: 15px 30px;
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Tela inicial -->
        <div id="initial-screen" class="screen">
            <h1>Jogo de Palavras</h1>
            <div class="input-group">
                <input type="text" id="player-name" placeholder="Seu nome" maxlength="15">
            </div>
            <div class="button-group">
                <button id="create-room">Criar Sala</button>
                <button id="join-room-btn">Entrar em Sala</button>
            </div>
            <div id="join-room-form" class="hidden">
                <input type="text" id="room-code" placeholder="Código da sala" maxlength="5">
                <button id="join-room-submit">Entrar</button>
            </div>
        </div>

        <!-- Tela de espera -->
        <div id="waiting-screen" class="screen hidden">
            <h2>Sala de Espera</h2>
            <div class="room-info">
                <p>Código da sala:</p>
                <div class="room-code"><span id="waiting-room-code"></span></div>
            </div>
            <div class="players-container">
                <h3>Jogadores na sala:</h3>
                <ul class="players-list" id="players-list">
                    <!-- Lista de jogadores será preenchida via JavaScript -->
                </ul>
            </div>
            <button id="start-game" class="start-game-btn">Iniciar Jogo</button>
        </div>

        <!-- Tela do jogo -->
        <div id="game-screen" class="screen hidden">
            <div class="game-header">
                <div id="room-info">Sala: <span id="room-code-display"></span></div>
                <div id="timer">Tempo: 0:00</div>
            </div>

            <div id="game-grid">
                <!-- 6 linhas com 5 slots cada serão criadas via JavaScript -->
            </div>

            <div id="keyboard">
                <!-- Teclado QWERTY será criado via JavaScript -->
            </div>
        </div>

        <!-- Tela de fim de jogo -->
        <div id="end-screen" class="screen hidden">
            <h2 id="end-message"></h2>
            <div id="game-stats">
                <p>Tentativas: <span id="attempts-count"></span></p>
                <p>Tempo: <span id="time-elapsed"></span></p>
            </div>
            <div id="leaderboard">
                <h3>Placar</h3>
                <table id="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Posição</th>
                            <th>Jogador</th>
                            <th>Tentativas</th>
                            <th>Tempo</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <button id="play-again">Jogar Novamente</button>
        </div>
    </div>

    <script>
class WordGame {
    constructor() {
        this.words = ['TERMO', 'PAPEL', 'FESTA', 'PRAIA', 'LIVRO', 'SONHO', 'MUNDO', 'FELIZ', 'CAMPO', 'TERRA'];
        this.currentAttempt = 0;
        this.currentPosition = 0;
        this.gameActive = false;
        this.startTime = null;
        this.playerName = '';
        this.roomCode = '';
        this.isRoomOwner = false;
        this.knownPositions = new Set(); // Armazena posições das letras já descobertas
        this.playersList = new Set();
        this.gameStarted = false;
        this.setupEventListeners();
        this.createGameGrid();
        this.createKeyboard();

        // Inicializar ou carregar salas
        this.rooms = JSON.parse(localStorage.getItem('wordGameRooms')) || [];
        
        // Iniciar verificação periódica da sala
        setInterval(() => this.checkRoomUpdates(), 1000);
    }

    setupEventListeners() {
        document.getElementById('create-room').addEventListener('click', () => this.createRoom());
        document.getElementById('join-room-btn').addEventListener('click', () => {
            document.getElementById('join-room-form').classList.remove('hidden');
        });
        document.getElementById('join-room-submit').addEventListener('click', () => this.joinRoom());
        document.getElementById('play-again').addEventListener('click', () => this.resetGame());
        document.getElementById('start-game').addEventListener('click', () => this.startGameSession());
        
        document.addEventListener('keydown', (e) => {
            if (!this.gameActive) return;
            
            if (e.key === 'Enter') {
                this.submitGuess();
            } else if (e.key === 'Backspace') {
                this.deleteLetter();
            } else if (/^[A-Za-z]$/.test(e.key)) {
                this.addLetter(e.key.toUpperCase());
            }
        });

        // Adicionar listener para copiar código da sala ao clicar
        document.getElementById('waiting-room-code').addEventListener('click', () => {
            navigator.clipboard.writeText(this.roomCode)
                .then(() => {
                    alert('Código da sala copiado!');
                })
                .catch(err => {
                    console.error('Erro ao copiar código:', err);
                });
        });
    }

    createGameGrid() {
        const gameGrid = document.getElementById('game-grid');
        gameGrid.innerHTML = '';
        
        for (let i = 0; i < 6; i++) {
            const row = document.createElement('div');
            row.className = 'grid-row';
            
            for (let j = 0; j < 5; j++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                
                // Adicionar evento de clique para seleção da célula
                cell.addEventListener('click', () => this.selectCell(i, j));
                
                row.appendChild(cell);
            }
            
            gameGrid.appendChild(row);
        }
        
        // Marcar a primeira célula como atual
        this.updateCurrentCell();
    }

    updatePlayersList() {
        const playersList = document.getElementById('players-list');
        playersList.innerHTML = '';
        
        this.playersList.forEach(player => {
            const li = document.createElement('li');
            li.textContent = player;
            playersList.appendChild(li);
        });

        // Mostrar/ocultar botão de início com base em ser o dono da sala
        const startButton = document.getElementById('start-game');
        startButton.style.display = this.isRoomOwner ? 'block' : 'none';
    }

    checkRoomUpdates() {
        if (!this.roomCode) return;

        const room = this.rooms.find(r => r.code === this.roomCode);
        if (!room) return;

        // Atualizar lista de jogadores
        this.playersList = new Set(room.players.map(p => p.name));
        this.updatePlayersList();

        // Verificar se o jogo começou
        if (room.gameStarted && !this.gameStarted) {
            this.startGame(room.word);
        }
    }
    
    selectCell(row, col) {
        if (!this.gameActive || row !== this.currentAttempt) return;
        
        // Não permitir selecionar células já preenchidas ou posições corretas
        const cell = document.querySelector(
            `.grid-cell[data-row="${row}"][data-col="${col}"]`
        );
        if (cell.classList.contains('filled') || this.knownPositions.has(col)) return;

        this.currentPosition = col;
        this.updateCurrentCell();
    }

    updateCurrentCell() {
        // Remover classe 'current' de todas as células
        document.querySelectorAll('.grid-cell').forEach(cell => {
            cell.classList.remove('current');
        });

        // Adicionar classe 'current' na célula atual
        const currentCell = document.querySelector(
            `.grid-cell[data-row="${this.currentAttempt}"][data-col="${this.currentPosition}"]`
        );
        if (currentCell) {
            currentCell.classList.add('current');
        }
    }

    createKeyboard() {
        const keyboard = document.getElementById('keyboard');
        const layout = [
            ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
            ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
            ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '⌫']
        ];

        keyboard.innerHTML = '';
        layout.forEach(row => {
            const keyboardRow = document.createElement('div');
            keyboardRow.className = 'keyboard-row';
            
            row.forEach(key => {
                const button = document.createElement('button');
                button.className = 'key';
                button.textContent = key;
                button.dataset.key = key;
                button.addEventListener('click', () => {
                    if (key === 'ENTER') {
                        this.submitGuess();
                    } else if (key === '⌫') {
                        this.deleteLetter();
                    } else {
                        this.addLetter(key);
                    }
                });
                keyboardRow.appendChild(button);
            });
            
            keyboard.appendChild(keyboardRow);
        });
    }

    generateRoomCode() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let code;
        do {
            code = '';
            for (let i = 0; i < 5; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
        } while (this.rooms.some(room => room.code === code));
        return code;
    }

    createRoom() {
        this.playerName = document.getElementById('player-name').value.trim();
        if (!this.playerName) {
            alert('Por favor, insira seu nome');
            return;
        }

        const roomCode = this.generateRoomCode();
        const word = this.words[Math.floor(Math.random() * this.words.length)];
        
        const room = {
            code: roomCode,
            word: word,
            players: [{
                name: this.playerName,
                attempts: 0,
                startTime: null
            }],
            gameStarted: false,
            leaderboard: []
        };

        this.rooms.push(room);
        localStorage.setItem('wordGameRooms', JSON.stringify(this.rooms));
        
        this.roomCode = roomCode;
        this.isRoomOwner = true;
        this.showWaitingRoom();
    }

    joinRoom() {
        this.playerName = document.getElementById('player-name').value.trim();
        const roomCode = document.getElementById('room-code').value.trim().toUpperCase();
        
        if (!this.playerName || !roomCode) {
            alert('Por favor, preencha todos os campos');
            return;
        }

        const room = this.rooms.find(r => r.code === roomCode);
        if (!room) {
            alert('Sala não encontrada');
            return;
        }

        if (room.gameStarted) {
            alert('Este jogo já começou!');
            return;
        }

        if (room.players.some(p => p.name === this.playerName)) {
            alert('Este nome já está em uso na sala');
            return;
        }

        room.players.push({
            name: this.playerName,
            attempts: 0,
            startTime: null
        });
        localStorage.setItem('wordGameRooms', JSON.stringify(this.rooms));

        this.roomCode = roomCode;
        this.isRoomOwner = false;
        this.showWaitingRoom();
    }

    showWaitingRoom() {
        document.getElementById('initial-screen').classList.add('hidden');
        document.getElementById('waiting-screen').classList.remove('hidden');
        document.getElementById('waiting-room-code').textContent = this.roomCode;
        
        const room = this.rooms.find(r => r.code === this.roomCode);
        this.playersList = new Set(room.players.map(p => p.name));
        this.updatePlayersList();
    }

    startGameSession() {
        if (!this.isRoomOwner) return;

        const room = this.rooms.find(r => r.code === this.roomCode);
        if (!room) return;

        if (room.players.length < 1) {
            alert('Aguarde pelo menos um jogador entrar na sala');
            return;
        }

        // Iniciar o jogo
        room.gameStarted = true;
        room.players.forEach(player => {
            player.startTime = Date.now();
        });
        localStorage.setItem('wordGameRooms', JSON.stringify(this.rooms));

        this.startGame(room.word);
    }

    startGame(word) {
        this.currentWord = word;
        this.gameStarted = true;
        document.getElementById('waiting-screen').classList.add('hidden');
        document.getElementById('game-screen').classList.remove('hidden');
        document.getElementById('room-code-display').textContent = this.roomCode;
        this.gameActive = true;
        this.startTime = Date.now();
        this.updateTimer();
    }

    updateTimer() {
        if (!this.gameActive) return;
        
        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('timer').textContent = 
            `Tempo: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        requestAnimationFrame(() => this.updateTimer());
    }

    addLetter(letter) {
        if (!this.gameActive || this.currentPosition >= 5) return;

        // Se a posição atual for uma posição correta já descoberta, não permitir alteração
        if (this.knownPositions.has(this.currentPosition)) {
            // Encontrar próxima posição disponível que não seja uma posição correta
            let nextPosition = this.currentPosition + 1;
            while (nextPosition < 5 && this.knownPositions.has(nextPosition)) {
                nextPosition++;
            }
            if (nextPosition < 5) {
                this.currentPosition = nextPosition;
                this.updateCurrentCell();
            }
            return;
        }

        const cell = document.querySelector(
            `.grid-cell[data-row="${this.currentAttempt}"][data-col="${this.currentPosition}"]`
        );
        cell.textContent = letter;
        cell.classList.add('filled');
        
        // Encontrar próxima posição disponível que não seja uma posição correta
        let nextPosition = this.currentPosition + 1;
        while (nextPosition < 5) {
            if (!this.knownPositions.has(nextPosition)) {
                const nextCell = document.querySelector(
                    `.grid-cell[data-row="${this.currentAttempt}"][data-col="${nextPosition}"]`
                );
                if (!nextCell.classList.contains('filled')) {
                    break;
                }
            }
            nextPosition++;
        }
        
        // Se não encontrar próxima posição, procurar posição anterior disponível
        if (nextPosition >= 5) {
            nextPosition = this.currentPosition - 1;
            while (nextPosition >= 0) {
                if (!this.knownPositions.has(nextPosition)) {
                    const nextCell = document.querySelector(
                        `.grid-cell[data-row="${this.currentAttempt}"][data-col="${nextPosition}"]`
                    );
                    if (!nextCell.classList.contains('filled')) {
                        break;
                    }
                }
                nextPosition--;
            }
        }
        
        // Atualizar posição atual se encontrou uma posição válida que não seja uma posição correta
        if (nextPosition >= 0 && nextPosition < 5 && !this.knownPositions.has(nextPosition)) {
            this.currentPosition = nextPosition;
            this.updateCurrentCell();
        } else {
            this.currentPosition = 5; // Todas as células preenchidas
        }
    }

    deleteLetter() {
        if (!this.gameActive || this.currentPosition === 0) return;

        // Se a posição atual for uma posição correta, não permitir deleção
        let position = this.currentPosition;
        if (position === 5) {
            // Se estamos no final, procurar a última posição não-correta
            position = 4;
            while (position >= 0 && this.knownPositions.has(position)) {
                position--;
            }
            if (position < 0) return; // Não há posições para deletar
        }

        // Se a posição atual for uma posição correta, não permitir deleção
        if (this.knownPositions.has(position)) return;

        this.currentPosition = position;
        const cell = document.querySelector(
            `.grid-cell[data-row="${this.currentAttempt}"][data-col="${this.currentPosition}"]`
        );
        cell.textContent = '';
        cell.classList.remove('filled');
    }

    submitGuess() {
        if (!this.gameActive || this.currentPosition !== 5) return;

        const guess = Array.from(document.querySelectorAll(
            `.grid-cell[data-row="${this.currentAttempt}"]`
        )).map(cell => cell.textContent).join('');

        const result = this.checkGuess(guess);
        this.updateUI(guess, result);

        if (guess === this.currentWord || this.currentAttempt === 5) {
            this.endGame(guess === this.currentWord);
        } else {
            this.currentAttempt++;
            this.currentPosition = 0;
        }
    }

    checkGuess(guess) {
        const result = Array(5).fill('gray');
        const wordArray = this.currentWord.split('');
        const guessArray = guess.split('');

        // Primeiro, marque as letras verdes (posição correta)
        for (let i = 0; i < 5; i++) {
            if (guessArray[i] === wordArray[i]) {
                result[i] = 'green';
                wordArray[i] = null;
                guessArray[i] = null;
            }
        }

        // Depois, marque as letras amarelas (letra correta, posição errada)
        for (let i = 0; i < 5; i++) {
            if (guessArray[i] === null) continue;
            
            const wordIndex = wordArray.indexOf(guessArray[i]);
            if (wordIndex !== -1) {
                result[i] = 'yellow';
                wordArray[wordIndex] = null;
            }
        }

        return result;
    }

    updateUI(guess, result) {
        // Atualizar células do grid
        result.forEach((color, index) => {
            const cell = document.querySelector(
                `.grid-cell[data-row="${this.currentAttempt}"][data-col="${index}"]`
            );
            cell.classList.add(color);
            
            // Se a letra estiver na posição correta, armazenar a posição
            if (color === 'green') {
                this.knownPositions.add(index);
            }
            
            // Atualizar teclado
            const letter = guess[index];
            const key = document.querySelector(`.key[data-key="${letter}"]`);
            if (key) {
                // Remover classes antigas se existirem
                key.classList.remove('correct', 'present', 'disabled');
                
                if (color === 'green') {
                    key.classList.add('correct');
                } else if (color === 'yellow') {
                    // Adiciona 'present' apenas se a letra não estiver já marcada como 'correct'
                    if (!key.classList.contains('correct')) {
                        key.classList.add('present');
                    }
                } else if (color === 'gray') {
                    // Adiciona 'disabled' apenas se a letra não estiver marcada como 'correct' ou 'present'
                    if (!key.classList.contains('correct') && !key.classList.contains('present')) {
                        key.classList.add('disabled');
                    }
                }
            }
        });
    }

    endGame(isWinner) {
        this.gameActive = false;
        const endTime = Date.now();
        const timeElapsed = (endTime - this.startTime) / 1000;

        // Atualizar leaderboard
        const room = this.rooms.find(r => r.code === this.roomCode);
        const score = {
            playerName: this.playerName,
            attempts: this.currentAttempt + 1,
            time: timeElapsed
        };
        room.leaderboard.push(score);
        room.leaderboard.sort((a, b) => {
            if (a.attempts !== b.attempts) return a.attempts - b.attempts;
            return a.time - b.time;
        });
        localStorage.setItem('wordGameRooms', JSON.stringify(this.rooms));

        // Atualizar UI
        const endScreen = document.getElementById('end-screen');
        const endMessage = document.getElementById('end-message');
        const attemptsCount = document.getElementById('attempts-count');
        const timeElapsedElement = document.getElementById('time-elapsed');
        const leaderboardTable = document.querySelector('#leaderboard-table tbody');

        endMessage.textContent = isWinner ? 
            'Parabéns! Você acertou!' : 
            `Fim de jogo! A palavra era ${this.currentWord}`;
        
        attemptsCount.textContent = this.currentAttempt + 1;
        timeElapsedElement.textContent = 
            `${Math.floor(timeElapsed / 60)}:${(Math.floor(timeElapsed) % 60).toString().padStart(2, '0')}`;

        // Preencher o placar
        leaderboardTable.innerHTML = '';
        room.leaderboard.forEach((score, index) => {
            const row = leaderboardTable.insertRow();
            row.insertCell(0).textContent = index + 1;
            row.insertCell(1).textContent = score.playerName;
            row.insertCell(2).textContent = score.attempts;
            row.insertCell(3).textContent = 
                `${Math.floor(score.time / 60)}:${(Math.floor(score.time) % 60).toString().padStart(2, '0')}`;
        });

        document.getElementById('game-screen').classList.add('hidden');
        endScreen.classList.remove('hidden');
    }

    resetGame() {
        document.getElementById('end-screen').classList.add('hidden');
        document.getElementById('initial-screen').classList.remove('hidden');
        this.currentAttempt = 0;
        this.currentPosition = 0;
        this.gameActive = false;
        this.startTime = null;
        this.roomCode = '';
        this.currentWord = '';
        this.createGameGrid();
        this.createKeyboard();
    }
}

// Iniciar o jogo quando a página carregar
window.addEventListener('load', () => {
    new WordGame();
});
    </script>
</body>
</html>